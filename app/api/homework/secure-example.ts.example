/**
 * EXAMPLE: Secure API Route Implementation
 * 
 * Ovaj fajl pokazuje kako da primenite sva bezbednosna unapređenja:
 * - CSRF protection
 * - Input validation
 * - Rate limiting
 * - Error handling
 * - Query optimization
 * 
 * USAGE:
 * 1. Copy ovaj kod u app/api/homework/route.ts
 * 2. Prilagodi za svoje potrebe
 * 3. Delete .example ekstenziju
 */

import { NextResponse } from "next/server";
import { auth } from "@/lib/auth/config";
import prisma from "@/lib/db/prisma";
import { z } from "zod";

// Security imports
import { csrfMiddleware } from "@/lib/security/csrf";
import { idSchema, safeIntSchema } from "@/lib/security/validators";
import { checkRateLimit } from "@/middleware/rate-limit";

/**
 * Input validation schema
 */
const createHomeworkSchema = z.object({
  title: z.string().min(1, "Naslov je obavezan").max(200, "Naslov je predugačak").trim(),
  description: z.string().max(2000, "Opis je predugačak").optional(),
  subjectId: idSchema,
  dueDate: z.string().datetime("Nevažeći datum"),
  priority: z.enum(["NORMAL", "IMPORTANT", "URGENT"]).default("NORMAL"),
});

const updateHomeworkSchema = createHomeworkSchema.partial();

/**
 * GET /api/homework - Fetch all homework
 */
export async function GET(req: Request) {
  try {
    // 1. Authentication
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized", message: "Morate biti ulogovani" },
        { status: 401 }
      );
    }

    // 2. Rate limiting
    const rateLimitResult = await checkRateLimit(req, "api");
    if (!rateLimitResult.success) {
      return rateLimitResult.response;
    }

    // 3. Get student ID
    const student = await prisma.student.findUnique({
      where: { userId: session.user.id },
      select: { id: true },
    });

    if (!student) {
      return NextResponse.json(
        { error: "Not Found", message: "Student profil nije pronađen" },
        { status: 404 }
      );
    }

    // 4. Parse query params for pagination
    const url = new URL(req.url);
    const page = Number.parseInt(url.searchParams.get("page") || "1", 10);
    const limit = Math.min(Number.parseInt(url.searchParams.get("limit") || "20", 10), 100);
    const skip = (page - 1) * limit;

    // 5. Optimized query - Select only needed fields
    const [homework, total] = await Promise.all([
      prisma.homework.findMany({
        where: { studentId: student.id },
        select: {
          id: true,
          title: true,
          description: true,
          dueDate: true,
          status: true,
          priority: true,
          createdAt: true,
          updatedAt: true,
          // Nested select - only needed fields
          subject: {
            select: {
              id: true,
              name: true,
              color: true,
              icon: true,
            },
          },
          // Limit attachments
          attachments: {
            select: {
              id: true,
              type: true,
              thumbnail: true,
            },
            take: 3, // Only first 3 thumbnails
          },
          // Count total attachments
          _count: {
            select: {
              attachments: true,
            },
          },
        },
        orderBy: { dueDate: "asc" },
        skip,
        take: limit,
      }),
      prisma.homework.count({
        where: { studentId: student.id },
      }),
    ]);

    // 6. Return with pagination metadata
    return NextResponse.json({
      data: homework,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasMore: skip + homework.length < total,
      },
    });

  } catch (error) {
    console.error("[GET /api/homework] Error:", error);

    // Don't leak error details to client
    return NextResponse.json(
      {
        error: "Internal Server Error",
        message: "Došlo je do greške prilikom učitavanja domaćih",
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/homework - Create new homework
 */
export async function POST(req: Request) {
  try {
    // 1. Authentication
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }

    // 2. CSRF Protection
    const csrfResult = await csrfMiddleware(req);
    if (!csrfResult.valid) {
      return NextResponse.json(
        { error: "Forbidden", message: csrfResult.error },
        { status: 403 }
      );
    }

    // 3. Rate limiting (stricter for POST)
    const rateLimitResult = await checkRateLimit(req, "api");
    if (!rateLimitResult.success) {
      return rateLimitResult.response;
    }

    // 4. Get student
    const student = await prisma.student.findUnique({
      where: { userId: session.user.id },
      select: { id: true },
    });

    if (!student) {
      return NextResponse.json(
        { error: "Not Found" },
        { status: 404 }
      );
    }

    // 5. Parse and validate input
    const body = await req.json();
    const validated = createHomeworkSchema.parse(body);

    // 6. Verify subject exists and belongs to student
    const subject = await prisma.subject.findFirst({
      where: {
        id: validated.subjectId,
        students: {
          some: {
            studentId: student.id,
          },
        },
      },
    });

    if (!subject) {
      return NextResponse.json(
        { error: "Bad Request", message: "Predmet nije pronađen" },
        { status: 400 }
      );
    }

    // 7. Create homework
    const homework = await prisma.homework.create({
      data: {
        ...validated,
        studentId: student.id,
      },
      include: {
        subject: {
          select: {
            id: true,
            name: true,
            color: true,
            icon: true,
          },
        },
      },
    });

    // 8. Log activity (for parental oversight)
    await prisma.activityLog.create({
      data: {
        studentId: student.id,
        type: "HOMEWORK_CREATED",
        description: `Kreiran domaći: ${homework.title}`,
        metadata: {
          homeworkId: homework.id,
          subjectId: homework.subjectId,
        },
        ipAddress: req.headers.get("x-forwarded-for") || req.headers.get("x-real-ip"),
        userAgent: req.headers.get("user-agent"),
      },
    });

    return NextResponse.json(homework, { status: 201 });

  } catch (error) {
    // Handle validation errors
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        {
          error: "Validation Error",
          message: "Neispravni podaci",
          details: error.errors,
        },
        { status: 400 }
      );
    }

    console.error("[POST /api/homework] Error:", error);

    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/homework/[id] - Update homework
 */
export async function PATCH(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    // 1. Authentication
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. CSRF Protection
    const csrfResult = await csrfMiddleware(req);
    if (!csrfResult.valid) {
      return NextResponse.json(
        { error: "Forbidden", message: csrfResult.error },
        { status: 403 }
      );
    }

    // 3. Validate ID format (prevent injection)
    const homeworkId = idSchema.parse(params.id);

    // 4. Get student
    const student = await prisma.student.findUnique({
      where: { userId: session.user.id },
      select: { id: true },
    });

    if (!student) {
      return NextResponse.json({ error: "Not Found" }, { status: 404 });
    }

    // 5. Verify homework exists and belongs to student
    const existingHomework = await prisma.homework.findFirst({
      where: {
        id: homeworkId,
        studentId: student.id,
      },
    });

    if (!existingHomework) {
      return NextResponse.json(
        { error: "Not Found", message: "Domaći nije pronađen" },
        { status: 404 }
      );
    }

    // 6. Parse and validate input
    const body = await req.json();
    const validated = updateHomeworkSchema.parse(body);

    // 7. Update homework
    const homework = await prisma.homework.update({
      where: { id: homeworkId },
      data: validated,
      include: {
        subject: {
          select: {
            id: true,
            name: true,
            color: true,
            icon: true,
          },
        },
      },
    });

    // 8. Log activity
    await prisma.activityLog.create({
      data: {
        studentId: student.id,
        type: "HOMEWORK_UPDATED",
        description: `Ažuriran domaći: ${homework.title}`,
        metadata: { homeworkId: homework.id },
      },
    });

    return NextResponse.json(homework);

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Validation Error", details: error.errors },
        { status: 400 }
      );
    }

    console.error("[PATCH /api/homework/[id]] Error:", error);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

/**
 * DELETE /api/homework/[id] - Delete homework
 */
export async function DELETE(
  req: Request,
  { params }: { params: { id: string } }
) {
  try {
    // 1. Authentication
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. CSRF Protection
    const csrfResult = await csrfMiddleware(req);
    if (!csrfResult.valid) {
      return NextResponse.json(
        { error: "Forbidden", message: csrfResult.error },
        { status: 403 }
      );
    }

    // 3. Validate ID
    const homeworkId = idSchema.parse(params.id);

    // 4. Get student
    const student = await prisma.student.findUnique({
      where: { userId: session.user.id },
      select: { id: true },
    });

    if (!student) {
      return NextResponse.json({ error: "Not Found" }, { status: 404 });
    }

    // 5. Verify ownership
    const homework = await prisma.homework.findFirst({
      where: {
        id: homeworkId,
        studentId: student.id,
      },
    });

    if (!homework) {
      return NextResponse.json({ error: "Not Found" }, { status: 404 });
    }

    // 6. Delete homework (will cascade delete attachments)
    await prisma.homework.delete({
      where: { id: homeworkId },
    });

    // 7. Log activity
    await prisma.activityLog.create({
      data: {
        studentId: student.id,
        type: "HOMEWORK_DELETED",
        description: `Obrisan domaći: ${homework.title}`,
        metadata: { homeworkId: homework.id },
      },
    });

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("[DELETE /api/homework/[id]] Error:", error);
    return NextResponse.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

